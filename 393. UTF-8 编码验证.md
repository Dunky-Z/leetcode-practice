---
title: 393. UTF-8 编码验证
tags: LeetCode
notebook: a - 001 | ITabc
---

给定一个表示数据的整数数组 `data` ，返回它是否为有效的 `UTF-8` 编码。

`UTF-8` 中的一个字符可能的长度为 `1 `到 `4` 字节，遵循以下的规则：

对于 `1` 字节 的字符，字节的第一位设为 `0` ，后面 `7` 位为这个符号的 unicode 码。

对于 `n` 字节 的字符 `(n > 1)`，第一个字节的前 `n` 位都设为`1`，第 `n+1` 位设为 `0` ，后面字节的前两位一律设为 `10` 。剩下的没有提及的二进制位，全部为这个符号的 `unicode` 码。

这是 `UTF-8` 编码的工作方式：
```
   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```
注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。

 

示例 1：
```
输入：data = [197,130,1]
输出：true
解释：数据表示字节序列:11000101 10000010 00000001。
这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。
```
示例 2：
```
输入：data = [235,140,4]
输出：false
解释：数据表示 8 位的序列: 11101011 10001100 00000100.
前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。
下一个字节是开头为 10 的延续字节，这是正确的。
但第二个延续字节不以 10 开头，所以是不符合规则的。
```

提示:
```
1 <= data.length <= 2 * 104
0 <= data[i] <= 255
```
Solution 1:

对于 UTF-8 编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII 码)；
如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非 ASCII 字符)；
如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节；
如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节；
如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节；

因此，对 UTF-8 编码中的任意字节，
根据第一位，可判断是否为 ASCII 字符；
根据前二位，可判断该字节是否为一个字符编码的第一个字节；
根据前四位（如果前两位均为1），可确定该字节为字符编码的第一个字节，并且可判断对应的字符由几个字节表示；
根据前五位（如果前四位为1），可判断编码是否有错误或数据传输过程中是否有错误。

那么根据上面的描述，
我们可以先来判断第一位，如果是0的话，则说明是 ASCII 码，我们直接跳过，判断方法是只要比二进制数 10000000 小的数第一位肯定是0，然后我们来处理第一位是1的情况，由于第一位的1只是个标识符，后面连续跟的1的个数才是表示后面的字节的个数，我们可以统一从第一位开始连续1的个数，然后减去1就是后面的字节的个数，我想的办法是如果该数字大于等于 128，则表示第一位是1，然后减去 128，如果得到的数大于等于 64，则表示第二位是1，依次类推就可以得到连续的个数 cnt，我们要注意 10000000 这个数是不合法的，所以当 cnt 为1的时候直接返回 false，还有就是连续1的个数不能超过4个，当 cnt 大于4时也是不合法的。即便是当 cnt 为 [2, 4] 之间的数，若后面没有跟正确个数的字节，还是非法的，所以当 cnt > n-i 时还是 false。我们得到了合法的 cnt 的个数，只要验证后面的字节是否是以 10 开头的数即可，验证方法也很简单，只要这个数在 10000000 ~ 10111111 范围之间，则一定是 10 开头的


```cpp
class Solution {
public:
    bool validUtf8(vector<int>& data) 
    {
        int n = data.size();
        for(int i = 0; i < n; ++i)
        {
            if(data[i] < 0b10000000)
            {
                continue;
            }
            else 
            {
                int cnt = 0, val = data[i];
                for(int j = 7; j >=1; --j)
                {
                    if(val >= pow(2, j))
                    {
                        ++cnt;
                    }
                    else
                    {
                        break;
                    }
                    val -= pow(2, j);
                }
                if(cnt == 1 || cnt > 4 || cnt > n - i) return false;
                for(int j = i + 1; j < i + cnt; ++j)
                {
                    if(data[j] > 0b10111111 || data[j] < 0b10000000) return false;
                }
                i += cnt - 1;
            }
        }
        return true;
    }
};
```

Solution 2:
```cpp
class Solution {
public:
    bool validUtf8(vector<int>& data) 
    {
        int cnt = 0;
        for (int d : data) 
        {
            if (cnt == 0) 
            {
                if ((d >> 5) == 0b110) cnt = 1;
                else if ((d >> 4) == 0b1110) cnt = 2;
                else if ((d >> 3) == 0b11110) cnt = 3;
                else if (d >> 7) return false;
            } else 
            {
                if ((d >> 6) != 0b10) return false;
                --cnt;
            }
        }
        return cnt == 0;
    }
};
```