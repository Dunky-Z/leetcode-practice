---
title: 程序员面试小手册
tags: c++
notebook: a - 001 | ITabc
---


#### 1. 请你说一说C++中struct和class
总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

在C++中引入struct是为了保持对C程序的兼容，在引入之后C++对其进行了扩充，现在struct可以拥有静态成员、成员数据可进行初始化、拥有函数、也可以继承、甚至多态也支持。从表面看起来两者之间像是没有区别，有时你把程序中的所有class改为struct，程序也照常运行。

最本质的一个区别就是默认的访问控制
- 默认的继承访问权限。struct 是 public 的，class 是 private 的。  
- struct 作为数据结构的实现体，它所有成员的默认访问级别为 public，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

#### 2. 请你说一说using关键字
**using声明**  
使用 using 声明可以在不需要加前缀namespace_name:: 的情况下访问命名空间中的名字。  

using 声明的形式如下：  
一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：
```c++
using namespace_name::name;
```

**using指示**  
using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：
```c++
using namespace std;
```

**尽量少使用 using 指示 污染命名空间**  
一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。
```c++
namespace blip
{
    int bi = 10,bj = 20,bk = 30;
}
int bj = 0;//命名空间外同名变量
void main()
{
    using namespace blip;
    ++bi;//right
    ++bj;//wrong , “bj”:不明确的符号
    ++::bj;//right,bj=1;
    ++blip::bj;//right,bj=21;
    int bk = 97;
    ++bk;//right,bk=98
}
```
尽量少使用 using 指示
```c++
using namespace std;
```
应该多使用 using 声明
```c++
int x;
std::cin >> x ;
std::cout << x << std::endl;
```
或者
```c++
using std::cin;
using std::cout;
using std::endl;
int x;
cin >> x;
cout << x << endl;
```

#### 3. 请你说一下static关键字的作用
- 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
- 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
- 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
- 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。
#### 4. C++中at()与方括号的区别
可以使用\[ \]或者at()方法来访问字符串中的字符,起始索引是0.最大有效索引是string.length()-1.(特别的,如果是const string类型的对象,那么最大有效索引是string.length(),最后一个字符是'\0’.)  
\[ \]和at()的区别在于\[ \]不检查索引是否有效,而at()在遇到无效索引时会抛出out_of_range异常.
#### 5. 请你说一下C++和C的区别
- 设计思想上  
C++是面向对象的语言，而C是面向过程的结构化编程语言
- 语法上
C++具有重载、继承和多态三种特性  
C++相比C，增加多许多类型安全的功能，比如强制类型转换  
C++支持范式编程，比如模板类、函数模板等

#### 6. 请你说说四种cast转换
1. const_cast  
用于将const变量转为非const
```cpp
const int a = 10;
int* pa = &a;//报错，因为指针会导致a发生改变，而a是const类型
int* pb = const_cast<int*>(&a);//正确
*pb = 100;

```
2. static_cast  
用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
3. dynamic_cast  
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。  
向上转换：指的是子类向基类的转换  
向下转换：指的是基类向子类的转换  
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。·
4. reinterpret_cast  
重新解释类型，既不检查指向的内容，也不检查指针类型本身；但要求转换前后的类型所占用内存大小一致，否则将弓|发编译时错误。  
几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

5. 为什么不使用C的强制转换？    
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。
#### 7. inline 内联函数
- 相当于不用执行进入函数的步骤，直接执行函数体；  
inline 函数避免函数调用的开销将函数指定为 inline 函数， （通常）就是将它在程序中每个调用点上“内联地”展开。假设我们将 shorterString 定义为内联函数，则调用：**cout << shorterString(s1, s2) << endl**。在编译时将展开为：**cout << (s1.size() < s2.size() ? s1 : s2) << endl**，从而消除了把 shorterString 写成函数的额外执行开销；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数；
- 内联函数应该在头文件中定义，这一点不同于其他函数，在头文件中加入或修改 inline 函数时，使用了该头文件的所有源文件都必须重新编译；
- 只有当函数只有 10 行甚至更少时才会将其定义为内联函数。
#### 8. 请你说说STL里resize和reserve的区别
- resize()  
改变当前容器内含有元素的数量，如果改变后的大小大于当前大小，容器就会新增一些元素，并且**默认值为0**
- reserve()  
改变当前容器的最大容量，他**不会生成元素**，只是确定这个容器允许放多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，校销毁之前的内存。

#### 9. 请你回答一下include头文件双引号和尖括号的区别
编译器处理阶段查找头文件的路径不一样
- 双引号  
当前头文件目录-编译器设置的头文件路径-系统变量指定的头文件路径
- 尖括号  
编译器设置的头文件路径-系统变量指定的头文件路径

#### 10. 请你说说你了解的const
- 作用  
    - 修饰变量，说明该变量不可以被改变；  
    - 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；  
    - 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；  
    - 修饰成员函数，说明该成员函数内不能修改成员变量。  


#### 11. 请你说说你了解的this指针
- this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。即在调用函数时初始化为调用函数的对象的地址。  
- this 指针被隐含地声明为: ClassName \*const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；  
- this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。  
- 在以下场景中，经常需要显式引用 this 指针：
    - 为实现对象的链式引用；
    - 为避免对同一对象进行赋值操作；
    - 在实现一些数据结构时，如 list

#### 12. volatile
- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 - volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

#### 13. sizeof()
- sizeof 对数组，得到整个数组所占空间大小，字节
- sizeof 对指针，得到指针本身所占空间大小

#### 14. union联合
联合（union）是一种节省空间的特殊的类，一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：
- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的
```cpp
#include<iostream>
union UnionTest {
    UnionTest() : i(10) {};
    int i;
    double d;
};
static union {
    int i;
    double d;
};
int main() 
{
    UnionTest u;
    union {
        int i;
        double d;
    };
    std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10
     
    ::i = 20;
    std::cout << ::i << std::endl;  // 输出全局静态匿名联合的20

    i = 30;
    std::cout << i << std::endl;    // 输出局部匿名联合的30
    return 0;
}
```

#### 15. ::范围解析运算符
- 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

#### 16. 内存分配和管理
- malloc  
申请指定字节数的内存，申请到的内存中的初始值不确定
- calloc  
为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一bit都初始化为0
- realloc  
更改以前分配的内存长度，当增加时，可能需要将以前分配区的内容移动到另一个足够大的区域，而新增区域的初始值不确定。

##### 16.1. new和malloc区别
1. new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；
2. new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。
3. new不仅分配一段内存，而且会调用构造函数，malloc不会。
4. new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。
5. new是一个操作符可以重载，malloc是一个库函数。
6. malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。
7. new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。
8. 申请数组时：new\[\]一次分配所有内存，多次调用构造函数，搭配使用delete\[\]，delete\[\]多次调用析构函数，销毁数组中的每个对象。而malloc 则只能sizeof（int）*n。

#### 17. 请说说指针与引用的区别
1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用sizeof()看一个指针的大小是4，而引用则是被引用对象的大小；
3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
5. 可以有const指针，但是没有const引用；
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；
7. 指针可以有多级指针（**p），而引用只有一级；
8. 指针和引用使用++运算符的意义不一样；
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

#### 18. 请你说说你理解的虚函数和多态
多态：相同对象收到不同消息（静态多态）或者不同对象收到相同消息(动态多态)时产生不同的动作。  

多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；  
实例：  
```cpp
class Rect
{
    public:
    int calcArea(int width);
    int calcArea(int width,int height);
}
```
在使用时当实例化一个Rect的对象后，就可以通过对象分别调用这两个函数，计算机在编译时，就会自动调用对应的函数。即程序运行之前，在编译阶段就已经确定下来到底要使用哪个函数。可见：很早就已经将函数编译进去了，称这种情况为早绑定或静态多态。
```cpp
int main()
{
    Rect rect;
    rect.calcArea(10);
    rect.calcArea(10，20);
    return 0;
}
```

动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了 virtual 关键字的函数，在子类中重写时候不需要加 virtual也是虚函数。  
实例：
定义一个形状类：Shape，有个计算面积的成员函数
```cpp
class Shape
{
    public 
    double calcArea()
    {
        cout<<"calcArea" << endl;
        return 0;
    }
}
```
再定义一个圆类Circle，它继承形状类，并有自己的构造函数和面积函数
```cpp
class Circle:public Shape
{
    public:
    Circle(double r);
    double calcArea();
    private:
    double r;
}
//面积函数的实现
double Circle::calcArea()
{
    return 3.14*r*r;
};
```
再定义一个矩形类Rect，它继承形状类，并有自己的构造函数和面积函数
```cpp
class Rect:public Shape
{
    public:
    Rect(double r);
    double calcArea();
    private:
    double width, height;
}
//面积函数的实现
double Circle::calcArea()
{
    return width * height;
};
```
可以使用父类指针指向子类对象，但结果却不尽如人意，因为调用的都是父类的计算面积的函数，也就是会打印输出两行calcArea
为何如此？  
- 如果以一个基础类指针指向一个衍生类对象(派生类对象)，那么经由该指针只能访问基础类定义的函数（静态联翩）  

- 如果基础类和衍生类定义了相同名称的成员函数，那么通过对象指针调用成员函数时，到底调用那个函数要根据**指针的原型**来确定，而不是根据指针实际指向的对象类型确定。
```cpp
int main()
{
    Shape *shape1 = new Circle(3);
    Shape *shape2 = new Rect(3,4);
    shape1->calcArea();
    shape2->calcArea();
    return 0;
}
//输出：
calcArea
calcArea
```
要实现动态多态就需要使用虚函数，在父类中，把想要实现多态的成员函数前加上virtual关键字使其成为虚函数。在子类同名函数前最好也加上virtual关键字，虽然可以不加，运行时系统自动加上，但是为了方便查看最好自己加上。
```cpp
class Shape
{
    public 
    virtual double calcArea()
    {
        cout<<"calcArea" << endl;
        return 0;
    }
}
class Rect:public Shape
{
    public:
    Rect(double r);
    virtual double calcArea();
    private:
    double width, height;
}
class Rect:public Shape
{
    public:
    Rect(double r);
    virtual double calcArea();
    private:
    double width, height;
}
```
使用父类指针指向子类对象，调用函数时，调用的就是对应子类的计算面积函数
```cpp
int main()
{
    Shape *shape1 = new Circle(3);
    Shape *shape2 = new Rect(3,4);
    shape1->calcArea();
    shape2->calcArea();
    delete shape1;
    delete shape2;
    return 0;
}
//输出：
28.26
12
```
虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。  

#### 19. 请你说说C++如何处理返回值
生成一个临时变量，把它的引用作为函数参数传入函数

#### 20. 请你说说重载与覆盖
重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中    
重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写


#### 21. 请你来回答一下 const  修饰成员函数的目的是什么？
const 修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上 const 限定，这样无论 const 对象还是普通对象都可以调用该函数。

#### 22. 请你说说map和set有什么区别，又是如何实现的？
map 和 set 都是 C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和 set 的操作行为，都只是
转调 RB-tree 的操作行为。   
区别：
- map 中的元素是 key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set 与之相对就是关键字的简单集合，set 中每个元素只包含一个关键字。
- set 的迭代器是 const 的，不允许修改元素的值；map 允许修改 value，但不允许修改key。其原因是因为 map 和 set 是根据关键字排序来保证其有序性的，如果允许修改 key 的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了 map 和 set 的结构，导致 iterator 失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以 STL 中将 set 的迭代器设置成 const，不允许修改迭代器的值；而 map 的迭代器则不允许修改 key 值，允许修改 value 值。
- map 支持下标操作，set 不支持下标操作。map 可以用 key 做下标，map 的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和 mapped_type类型默认值的元素至 map 中，因此下标运算符[ ]在 map 应用中需要慎用，const_map 不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type 类型没有默认值也不应该使用。如果 find 能解决需要，尽可能用 find。

#### 23. 请你说说STL迭代器删除元素
这个主要考察的是迭代器失效的问题。
1. 对于序列容器 vector,deque 来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是 erase 会返回下一个有效的迭代器；
```cpp
for(vector<int>::iterator it = vecInt.begin(); it != vecInt.end();)
{
    if(*it == 0)
    {
        it = vecInt.erase(it);
    }
    else
    {
        it++;
    }
}
```
2. 对于关联容器 map set 来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用 erase 之前，记录下一个元素的迭代器即可。  

例：
```cpp
for(map<int,int>::iterator it = mapInt.begin(); it != mapInt.end();)
{
    if(it->second == 0)
    {
        mapInt.erase(it++);
    }
    else
    {
        it++;
    }
}
```
    该方法中利用了后缀++的特点，这个时候执行mapInt.erase(it++);这条语句分为三个过程   
    - 先把it的值赋值给一个临时变量做为传递给erase的参数变量
    - 因为参数处理优先于函数调用，所以接下来执行了it++操作，也就是it现在已经指向了下一个地址。
    - 再调用erase函数，释放掉第一步中保存的要删除的it的值的临时变量所指的位置。 
3. 对于 list来说，它使用了不连续分配的内存，并且它的 erase 方法也会返回下一个有效的 iterator，因此上面两种正确的方法都可以使用。

但是有一种错误的写法一定要注意：
```cpp
list< int> List;
list< int>::iterator iter;
for( iter = List.begin(); iter != List.end(); )
{
    if(1)  
    {
        List.erase( iter );
    }
    iter++;
}
```
因为执行erase后iter所指的地址就会被销毁，同时返回下一个位置的迭代器，如果在执行iter++就会出错。所以要不就用迭代器接受当前位置：iter = List.erase(iter),要不就用++ 运算：List。erase（iter++）。

#### 24. 请你说说vector与list的区别
vector  
- 连续存储的容器，动态数组，在堆上分配空间，底层实现是数组。扩容时分配两倍于原来空间的新空间，再将原来内容复制过来。并析构原来空间。
- 性能  
访问：O(1)  
插入：  
在最后插入（空间足够）-很快  
在最后插入（空间不够）- 需要内存申请与释放，以及复制之前数据  
在中间插入（空间足够）- 内存拷贝  
在中间插入（空间不够）- 需要内存申请与释放，以及对复制之前数据  
删除：  
在最后删除- 很快
在中间删除- 内存拷贝

- 适用场景 ：经常随机访问，且不经常对非尾部节点进行插入删除

list   
- 动态链表，在堆上分配空间，没插入一个元素都会分配空间，每删除一个元素都会释放空间。底层由双向链表实现
- 性能  
访问：随机访问性能很差，只能快速访问头尾节点  
插入：很快，一般是常数开销  
删除：很快，一般是常数开销  

#### 25. 请你说说STL迭代器的作用，有指针为何还要迭代器？
Iterator模式又称为Cursor模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说：Iterator 模式是运用于聚合对象的一种模式，通过运用该模式，**使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由 iterator 提供的方法）访问聚合对象中的各个元素**。

**与指针的区别**  
迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、\*、++、--等。迭代器封装了指针，是一个“可遍历 STL（ Standard TemplateLibrary）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。迭代器返回的是对象引用而不是对象的值，所以 cout 只能输出迭代器使用\*取值后的值而不能直接输出其自身。

**迭代器补充**
```cpp
//遍历
//C++11
unordered_map<int, string> m;
for(auto& p : m)
    cout << p.first ":"<< p.second << endl;
//C++17
unordered_map<int, string> m;
for(auto& [key, value] : m)
    cout << key ":"<< value << endl;
```
```cpp
//访问
//不同容器之间的转换可以用迭代器方便的完成
set<int> s{1, 2, 3};
vector<int> v(begin(s), end(s));
//函数返回值是个容器可以通过列表初始化返回
vector<int> fun()
{
    deque<int> r{1, 2, 3};
    return {rbegin(r), rend(r)};//3,2,1
}
```
```cpp

//不使用迭代器
map<int, int> m;
if(m.count(x))//O(logn)
{
    foo(m[x]);//O(logn)
    m.erase(x);//O(logn),erase参数如果是int，实际是还是需要通过迭代器操作转换成对应的迭代器
}
//使用迭代器可以降低时间复杂度
auto it = m.find(x);//O(logn)
if(it != end(m))
{
    foo(it->second);//O(1)
    s.erase(it);//O(1)
}

```


#### 26. 请你说说左值引用与右值引用？
左值右值的概念  
左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。
右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。
```cpp
int var;
var = 4;
//var左值
//4 右值
```
右值引用：  
1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。  
2. 能够更简洁明确地定义泛型函数。  
3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数
改变）。
```cpp
int a = 10; 
int& refA = a; // refA是a的别名， 修改refA就是修改a, a是左值，左移是左值引用
int& b = 1; //编译错误! 1是右值，不能够使用左值引用
```
c++右值引用符号是&&，如：
```cpp
int&& a = 1; //实质上就是将不具名(匿名)变量取了个别名
int b = 1;
int && c = b; //编译错误！ 不能将一个左值复制给一个右值引用
class A 
{
  public:
    int a;
};
A getTemp()
{
    return A();
}
A && a = getTemp();   //getTemp()的返回值是右值（临时变量）
```
getTemp()返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量），而通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量a的生命期一样，只要a还活着，该右值临时变量将会一直存活下去。实际上就是给那个临时变量取了个名字。  
**注意**：这里a的类型是右值引用类型(int &&)，但是如果从左值和右值的角度区分它，它实际上是个左值。因为可以对它取地址，而且它还有名字，是一个已经命名的右值。  
所以，左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。但是，常量左值引用却是个奇葩，它可以算是一个“万能”的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。
```cpp
const int & a = 1; //常量左值引用绑定 右值， 不会报错
class A 
{
  public:
    int a;
};
A getTemp()
{
    return A();
}
const A & a = getTemp();   //不会报错 而 A& a 会报错
```

#### 右值引用 
他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。  
[博客“从四行代码看右值引用”](https://www.cnblogs.com/qicosmos/p/4283455.html)


#### 27. 请你说说C++源文件从文本到可执行文件经历的过程？
- 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件
- 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件(const常量值在此阶段确定其值后就不再改变)
- 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
- 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件

#### 28. 段错误
段错误通常发生在访问非法内存地址的时候，分为以下几种：  
- 使用野指针
- 试图修改字符串常量的内容

#### 29. 请你或说C++的内存管理
![20200502141221](https://raw.githubusercontent.com/Dunky-Z/MarkdownImageBed/master/img/20200502141221.png)

32bitCPU 可寻址 4G 线性空间，每个进程都有各自独立的 4G 逻辑地址，其中 0~3G 是用户态
空间，3~4G 是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：  
**静态区域**
- text segment(代码段)： 包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
- data segment(数据段)： 存储程序中已初始化的全局变量和静态变量
- bss segment(bss段)： 存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行 main 之前时会统一清零。即未初始化的全局变量编译器会初始化为0    

**动态区域**：
- heap（堆）： 当进程未调用 malloc 时是没有堆段的，只有调用 malloc 时才用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动 break 指针)，从低地址向高地址增长。分配小内存时使用该区域。 堆的起始地址由 mm_struct 结构体中的 start_brk 标识，结束地址由 brk标识。
- memory mapping segment（映射区）：存储动态链接库等文件映射、申请大内存（malloc 时调用 mmap 函数）
- stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux 可以通过 ulimit 命令指定。

#### 30. C++内存分配中堆与栈的区别
堆和栈的第一个区别就是申请方式的不同，栈是系统自动分配空间的，而堆则是程序员根据需要自己申请的空间。由于栈空间是自动分配自动回收的，所以栈上的数据生存周期存在于函数的运行过程。运行结束后，数据就不可访问。而堆上的数据只要程序不释放空间，就一直可以访问到，不过缺点就是一旦忘记释放就会造成内存泄漏。
- 申请后系统的响应  
栈：只要栈的剩余空间大于申请空间系统就为程序提供内存，否则报栈溢出错误  
堆：操作系统有一个记录空闲内存地址的链表，当系统受到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题
- 申请效率  
栈：系统自动分配，速度快，但不自由  
堆：人为分配，使用方便
- 申请大小的限制  
栈：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数）。因此，能从栈获得的空间较小。  
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
- 保存的内容区别  
栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的吓一跳可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是有右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行  
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排  
#### 31. const与#define的区别
1. 编译器处理方式   
define – 在预处理阶段进行替换   
const – 在编译时确定其值

2. 类型检查  
define – 无类型，不进行类型安全检查，可能会产生意想不到的错误  
const – 有数据类型，编译时会进行类型检查，检查是否有改变对象的语句，如果有则会报语法错误

3. 内存空间  
define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大      
const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

4. 其他   
在编译时， 编译器通常不为**const常量**分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。   
**宏替**换只作替换，不做计算，不做表达式求解。

#### 32. sizeof和strlen的区别
sizeof()是**操作符**，参数为任意类型，主要计算类型占用内存大小  
strlen()是**函数**，其函数原型为：extern unsigned int strlen(char* s)；其参数为char\*,strlen只能计算以"\0"结尾字符串的长度，计算结果不包括"\0"。
```cpp
char* ss = "0123456789";  
//s1=4,ss为字符指针在内存中占用4个字节  
int s1 = sizeof(ss);  
//s2=10,计算字符串ss的长度  
int s2 = strlen(ss);  
```


#### 33. 32位，64位系统数据类型占用字节数？
|数据类型|32位|6位|
|-|-|-|
|char|1|1|
|指针变量*|4|8|
|short int|2|2|
|int|4|4|
|unsigned int|4|4|
|float|4|4|
|double|8|8|
|long|4|8|
|unsigned long|4|8|
|long long|8|8|
除了指针和long都相同
#### 34. 请你说说深拷贝与浅拷贝的区别？
- 浅拷贝  
对象的数据资源是由指针指向的堆时,默认的拷贝构造函数只是将指针复制。 
```
MySrting S1, S2;
//由于已经重载看“=”，可以将字符串复制给一个对象这个操作
S1 = "this";
S2 = "that";
S1 = S2;
//S2逐个字节的复制给S2
```
![Image](https://raw.githubusercontent.com/Dunky-Z/MarkdownImageBed/master/img/Image.png)

在执行S1=S2操作时，将S2的str指向值逐个字节复制给了S1的str指向的空间。即两个对象共同指向了S2的str所指向的那块内存。这也引发了两个问题：
1. S1.str不再指向原来的内存，那原来的内存就没有任何指针来控制，它就编程了一块垃圾内存
1. S1.str,S2.str同时指向了一片内存，当S1，S2同时消亡的时候，因为指向了同一块内存，这块内存就会被释放两次，这就会导致严重内存错误


- 深拷贝  
![20200503211648](https://raw.githubusercontent.com/Dunky-Z/MarkdownImageBed/master/img/20200503211648.png)  
将一个对象中指针变量指向的内容复制到另一个对象中指针成员对象指向的地方
在类中重载=运算符
```
String & operator = (const String & s)
{
    if(str) delete [] str;            //先将原先存储的内容删除
    str = new char[strlen(s.str)+1];  //重新分配一个空间
    strcpy(str, s.str);               //复制内容
    return * this;
}
```
但是仍然会有一个问题：
    如果指向自身复制的话就会出错
因为在重载函数中我们首先要判断是否存放内容，如果存放就删除，而自身复制时肯定原先是存放内容的，如果删除，再执行后面的复制操作肯定就会出错，所以：
```
//在重载函数开头添加下面语句
    if(str == s.str) return * this;
```

#### 35. 说几个C++11的新特性
- auto类型推导
- 范围for循环
- lambda函数
- override和final关键字
- 空指针常量nullptr
- 智能指针

#### 36. 智能指针
四个智能指针 auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是C++11 支持，并且第一个已经被C++11 弃用。
为什么要使用智能指针：
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为**智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数**，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。
1. auto_ptr  

采用所有权模式。
```cpp
auto_ptr<string> p1 (new string ("I Love China"));
auto_ptr<string> p2;
p2 = p1; //auto_ptr 不会报错.
```
此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1 将会报错。所以 auto_ptr的缺点是：存在潜在的内存崩溃问题！  

2. unique_ptr（替换 auto_ptr）  

unique_ptr 实现独占式拥有或严格拥有概念，**保证同一时间内只有一个智能指针可以指向该对象**。它对于避免资源泄露(例如“以 new 创建对象后因为发生异常而忘记调用delete”)特别有用。  
采用所有权模式，还是上面那个例子
```cpp
unique_ptr<string> p3 (new string ("auto")); //#4
unique_ptr<string> p4； //#5
p4 = p3;//此时会报错！！
```

编译器认为 p4=p3 非法，避免了 p3 不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr更安全。  
另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：
```cpp
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1; // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You")); // #2 allowed
```
注：如果确实想执行类似与#1 的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数 std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：
```cpp
unique_ptr<string> ps1, ps2;
ps1 = unique_ptr<string>(new string("hello"));
ps2 = std::move(ps1);
ps1 = unique_ptr<string>(new string("alexia"));
cout << *ps2 << "   " << *ps1 << endl;
//输出:hello   alexia
```

3. shared_ptr  

shared_ptr 实现**共享式拥有**概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count()来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入 auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用 release()时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被释放。  
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
```cpp
成员函数：
use_count()   //返回引用计数的个数
unique()      //返回是否是独占所有权( use_count 为 1)
swap()        //交换两个 shared_ptr 对象(即交换所拥有的对象)
reset()       //放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
get()         //返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的
```

初始化：
```cpp
int main()
{　　
　　/*---------空指针------------*/
　　 shared_ptr<string> p1;
    if(!p1)                     　　　　//!默认初始化的智能指针中保存着一个空指针！并不是""空字符串
        cout<<"p1==NULL"<<endl;
　　/*---------初始化------------*/
　　shared_ptr<string> p2(new string); 
　　if(p2&&p2->empty()){ 　　　　　　　　//！需要注意的时empty时属于string的成员函数。 
　　　　*p2="helloworld"; 
　　　　cout<<*p2<<endl;
　　}
//    shared_ptr<int> pa = new int(1);//！error:不允许以暴露裸漏的指针进行赋值操作。
　　//一般的初始化方式
    shared_ptr<string> pint(new string("normal usage!"));
    cout<<*pint<<endl;
    //推荐的安全的初始化方式
    shared_ptr<string> pint1 = make_shared<string>("safe uage!");
    cout<<*pint1<<endl;
}

输出：
p1==NULL
helloworld
normal usage!
safe uage!
```
引用计数：  
无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr去初始化另一个shared_ptr；当我们给shared_ptr赋予一个新的值或者是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域)时，计数器就会递减。一旦一个shared_ptr的计数器变为0，他就会自动释放自己所管理的对象。
```cpp
int main()
{
    auto p = make_shared<int>(42); //指向的对象只有p一个引用者。
    cout<<p.use_count()<<endl;
    auto q = make_shared<int>(56);//指向的对象只有q一个引用者。
    cout<<q.use_count()<<endl;

    cout<<"---------afterAssin-----"<<endl;
    p = q;                        //p原来引用的对象（42）经过赋值之后释放掉了，q引用的对象（56）有了p和q两个引用。
    //一个指针去初始化另一个指针，引用计数会增加从1到2
    cout<<*p<<"=="<<*q<<endl;
    cout<<q.use_count()<<endl;
    cout<<"-------------"<<endl;
    q = make_shared<int>(10); //给指针赋予一个新值后，引用计数会减少从2到1
    cout << q.use_count() << endl;
}
输出：
1
1
---------afterAssin-----
56==56
2
------------------------
1
```

4. weak_ptr 

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象.进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr **只是提供了对管理对象的一个访问手段**。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助
shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题,如果说两个 shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为 0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。
```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;
class ClassB;
class ClassA
{
public:
    ClassA() { cout << "ClassA Constructor..." << endl; }
    ~ClassA() { cout << "ClassA Destructor..." << endl; }
    shared_ptr<ClassB> pb;  // 在A中引用B
};
class ClassB
{
public:
    ClassB() { cout << "ClassB Constructor..." << endl; }
    ~ClassB() { cout << "ClassB Destructor..." << endl; }
    shared_ptr<ClassA> pa;  // 在B中引用A
};
int main() 
{
    shared_ptr<ClassA> spa = make_shared<ClassA>();
    shared_ptr<ClassB> spb = make_shared<ClassB>();
    spa->pb = spb;
    spb->pa = spa;
    std::cout << "spa use_cout:" << spa.use_count() << " spb use_cout:" << spb.use_count() << std::endl;　　//spa: 2 spb:2
　　// 函数结束，思考一下：spa和spb会释放资源么？ 超过作用于时引用计数减一，此时为2，减一后不为0，所以内存不释放
}
输出：
ClassA Constructor...
ClassB Constructor...
spa use_cout:2 spb use_cout:2
```
spa和spb之间存在相互引用，两个资源的引用计数为2，当main函数结束时，智能指针spa，spb的引用计数分别减1后还是1。所以它们并不会被释放。  

如果把其中一个改为 weak_ptr 就可以了，我们把类 A 里面的 shared_ptr spb; 改为 weak_ptr spb; 运行结果如下，这样的话，资源 B 的引用开始就只有 1，当 spb 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 spa 析构时使 A 的计数减一，那么 A 的计数为 0，A 得到释放。

注意的是我们不能通过 weak_ptr 直接访问对象的方法，比如 B 对象中有一个方法 print(),我们不能这样访问，pa->pb_->print(); 英文 pb_是一个 weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();

#### 37. C与C++的区别
C++在C的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

#### 38. C++中数据成员初始化顺序
1. 成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。

2. 如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。

3. 类中const成员常量必须在构造函数初始化列表中初始化。

4. 类中static成员变量，只能在类内外初始化(同一类的所有实例共享静态成员变量)。

初始化顺序：  
1. 基类的静态变量或全局变量
2. 派生类的静态变量或全局变量
3. 基类的成员变量
4. 派生类的成员变量

#### 39. C++中空类的大小是多少？
```cpp
class A {};: sizeof(A) = 1;
class A { virtual Fun(){} };: sizeof(A) = 4(32位机器)/8(64位机器);
class A { static int a; };: sizeof(A) = 1;
class A { int a; };: sizeof(A) = 4;
class A { static int a; int b; };: sizeof(A) = 4;
```
空类的大小为1，因为每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了一个独一无二的地址。

#### 40. 友元类与友元函数

友元提供了**不同类的成员函数之间**、**类的成员函数与一般函数**之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。
- 友元函数  
友元函数是可以直接**访问类的私有成员**的**非成员函数**。它是定义在类外的普通函数，它不属于任何类，但**需要在类的定义中加以声明**，声明时只需在友元的名称前加上关键字friend。
- 友元类  
友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望**一个类可以存取另一个类的私有成员**时，可以将该类声明为另一类的友元类。

例：

```cpp
#include <iostream>
using namespace std;
class Radius
{
	friend class Circle;        //声明Circle为Radius的友元类
	friend void Show_r(Radius &n); //声明Show_r为友元函数
public:
	Radius(int x)
	{
		r = x;
	}
	~Radius()
	{
	}
private:
	int r;
};

void Show_r(Radius &n)
{
	cout << "圆的半径为: " << n.r << endl;  //调用Radius对象的私有成员变量r
}

class Circle
{
public:
	Circle() {}
	~Circle() {}
	double area(Radius a)
	{
		s = a.r * a.r * 3.1415926;  //调用Radius对象的私有成员变量r
		return s;
	}
private:
	double s;
};

int main(int argc, char *argv[])
{
	Radius objRadius(9);
	Circle objCircle;

	Show_r(objRadius);
	cout << "面积为：" << objCircle.area(objRadius) << endl;

	return 0;
}
```

- 注意事项  
1. 友元关系不能被继承。 
2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 
3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明


#### 41. 为什么析构函数必须是虚函数，C++默认析构函数不是虚函数？
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

#### 42. 函数指针
如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称**函数指针**。

```cpp
int Func(int x);   /*声明一个函数*/
int (*p) (int x);  /*定义一个函数指针*/
p = Func;          /*将Func函数的首地址赋给指针变量p*/
```
#### 43. fork函数
创建一个和当前进程映像一样的进程  
成功调用 fork( )会创建一个新的进程，它几乎与调用 fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的 fork( )调用会返回 0。在父进程中 fork( )返回子进程的 pid。如果出现错误，fork( )返回一个负值。  
最常见的 fork( )用法是创建一个新的进程，然后使用 exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

#### 44. 写一个在main函数执行之前运行的函数
GCC的__attribute__属性设置可以将函数设置成类似于这样功能的函数：
```cpp
__attribute__((constructor)) // 在main函数被调用之前调用
__attribute__((destructor)) // 在main函数被调用之后调
```

```cpp
__attribute((constructor))void before()
{
    printf("before main\n");
}
```

#### 45. C++11可变模板
C++11 的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在 class 或 typename 后面带上省略号
```cpp
Template<class ... T>
void func(T ... args)
{
    cout << "num is" << sizeof ... (args) <<< endl;
}
func(); //args不含任何参数
func(1); //args包含一个int类型的实参
func(1,2.9） // 包含一个int一个double类型的实参
```
这个例子只是简单的将可变模版参数的个数打印出来，如果我们需要将参数包中的每个参数打印出来的话就需要通过一些方法了。  
展开可变模版参数函数的方法一般有两种：一种是通过递归函数来展开参数包，另外一种是通过逗号表达式来展开参数包。下面来看看如何用这两种方法来展开参数包。

T叫做模板参数包，args 叫做函数参数包
省略号作用如下：  
- 声明一个包含 0 到任意个模板参数的参数包
- 在模板定义得右边，可以将参数包展成一个个独立的参数  

C++11 可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：
```cpp
#include using namespace std;
// 最终递归函数
void print()
{
    cout << "empty" << endl;
}
// 展开函数
template void print(T head, Args... args)
{
    cout << head << ","; 
    print(args...);
}
int main()
{
    print(1, 2, 3, 4); 
    return 0;
}
```
参数包 Args ...在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数 printf 终止递归过程。   
当参数包展开到最后一个参数时递归为止。再看一个通过可变模版参数求和的例子：   
```cpp
template<typename T>
T sum(T t)
{
    return t;
}
template<typename T, typename ... Types>
T sum (T first, Types ... rest)
{
    return first + sum<T>(rest...);
}

sum(1,2,3,4); //10
```

