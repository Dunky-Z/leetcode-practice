---
title: 剑指 Offer 65. 不用加减乘除做加法
tags: LeetCode,位运算
notebook: a - 001 | ITabc
---
写一个函数，求两个整数之和，要求在函数体内不得使用 `“+”、“-”、“*”、“/”` 四则运算符号。
示例:
```
输入: a = 1, b = 1
输出: 2
```

提示：
```
a, b 均可能是负数或 0
结果不会溢出 32 位整数
```

---
Solution 1:
>runtime error: left shift of negative value -2147483648，对INT_MIN左移位。
就是 LeetCode 自己的编译器比较 strict，不能对负数进行左移，就是说最高位符号位必须要为0，才能左移（此处应有尼克杨问号脸？！），好吧，你赢了。那么在a和b相 '与' 之后，再'与'上一个最高位为0，其余位都为1的数 0x7fffffff，这样可以强制将最高位清零，然后再进行左移

第一步不考虑进位对每一位相加。0加0、1加1的结果都是0，0加1、1加0的结果都是1。我们注意到，这和异或的结果是一样的。对异或而言，0和0、1和1的异或结果是0，而0和1、1和0的异或结果是1。
接着考虑第二步进位，对0加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。此时我们可以想象成两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0。
第三步把前两个步骤的结果相加。第三步相加的过程依然是重复前面两步，直到不产生进位为止。

```cpp
class Solution {
public:
    int add(int a, int b) 
    {
        while(b != 0)
        {
            int carry = (a & b & 0x7fffffff) << 1;
            a = a ^ b;
            b = carry;
        }
        return a;
    }
};
```