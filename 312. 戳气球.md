---
title: 312. 戳气球
tags: LeetCode,动态规划
notebook: a - 001 | ITabc
---
有`n`个气球，编号为`0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。
现在要求你戳破所有的气球。如果你戳破气球 `i` ，就可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。求所能获得硬币的最大数量。
说明:  
你可以假设 `nums[-1] = nums[n] = 1`，但注意它们不是真实存在的所以并不能被戳破。
```
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100
```
示例:
```cpp
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

Solution 1:
|`i-1`|`i`|···|`k-1`|`k`|`k+1`|···|`j`|`j+1`|
|-|-|-|-|-|-|-|-|-|

这道题是问怎么戳爆气球得最高分。每戳爆一个球，都会导致两个不相邻的球变成相邻，增加了难度。可以反过来想，先考虑最后留哪个球。假如留下第`k`个球，这就将区间划分成了三份`[i,k-1][k][k+1, j]`。只要之前更新过了 `[i, k-1] `和 `[k+1, j]` 这两个子区间的`dp` 值，可以直接用 `dp[i][k-1]` 和 `dp[k+1][j]`来更新`dp[i][j]`。最后戳爆第`k`个气球时的得分怎么算？如果这么算就大错特错了：`nums[k-1] * nums[k] * nums[k+1]`。此时与`k`相邻的气球已经在计算`dp[i][k-1]`区间时被戳破了。正确的算法是与首位两个空位置相乘：`nums[i-1] * nums[k] * nums[j+1]`。那么**状态转移方程**就很容易得到了：`dp[i][j] =  max(dp[i][j], nums[i - 1] * nums[k] * nums[j + 1] + dp[i][k - 1] + dp[k + 1][j])  `

>有了状态转移方程了，就可以写代码，下面就遇到本题的第二大难点了，区间的遍历顺序。一般来说，遍历所有子区间的顺序都是i从0到n，然后j从i到n，然后得到的 `[i, j]` 就是子区间。但是这道题用这种遍历顺序就不对，在前面的分析中已经说了，这里需要先更新完所有的小区间，然后才能去更新大区间，而用这种一般的遍历子区间的顺序，会在更新完所有小区间之前就更新了大区间，从而不一定能算出正确的dp值，比如拿题目中的那个例子`[3, 1, 5, 8]`来说，一般的遍历顺序是：
>`[3] -> [3, 1] -> [3, 1, 5] -> [3, 1, 5, 8] -> [1] -> [1, 5] -> [1, 5, 8] -> [5] -> [5, 8] -> [8] `
>显然不是我们需要的遍历顺序，正确的顺序应该是先遍历完所有长度为1的区间，再是长度为2的区间，再依次累加长度，直到最后才遍历整个区间：
>`[3] -> [1] -> [5] -> [8] -> [3, 1] -> [1, 5] -> [5, 8] -> [3, 1, 5] -> [1, 5, 8] -> [3, 1, 5, 8]`
>引用自[Grandyang](https://www.cnblogs.com/grandyang/p/5006441.html)

```cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) 
    {
        size_t n = nums.size();
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        vector<vector<int>> dp(n+2, vector<int>(n+2, 0));
        //从区间大小为1开始计算，知道计算最大区间n
        for(size_t len = 1; len  <= n; ++len)
        {
            //因为0位置是最后戳爆气球的边界
            for(size_t i = 1; i <= n - len + 1; ++i)
            {
                size_t j = i + len - 1;
                for(size_t k = i; k <= j; ++k)
                {
                    dp[i][j] = max(dp[i][j], dp[i][k - 1] + nums[i - 1] * nums[k] * nums[j + 1] + dp[k + 1][j]);
                }
            }
        }
        return dp[1][n];
    }
};
```